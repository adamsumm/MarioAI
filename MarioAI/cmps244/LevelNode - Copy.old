package cmps244;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Random;

import org.json.JSONObject;

import cmps244Lib.WeightPair;


public class LevelNode {
	public int x;
	public boolean wildCard;
	//public ArrayList<WeightPair<String> >  potentialLeft;
	public ArrayList<WeightPair<String> >  potentialRight;
	public ArrayList<LevelNode> children;
	public String levelChunk;
	public static Hashtable<String, LevelNode> levelPieces = new Hashtable<String,LevelNode>();
	public LevelNode(String chunk,JSONObject json){
		children = new ArrayList<LevelNode>();
		levelChunk = chunk;
		JSONObject directions = json.getJSONObject(chunk);
		JSONObject rightJSON = directions.getJSONObject("right");
		JSONObject leftJSON = directions.getJSONObject("left");
		
		String[] rightNodes = JSONObject.getNames(rightJSON);
		potentialRight = new ArrayList<WeightPair<String> >();
		for (String node : rightNodes){
			potentialRight.add(new WeightPair<String>(rightJSON.getInt(node),node));
		}
/*
		String[] leftNodes = JSONObject.getNames(leftJSON);
		potentialLeft = new ArrayList<WeightPair<String> >();
		for (String node : leftNodes){
			potentialLeft.add(new WeightPair<String>(leftJSON.getInt(node),node));
		}
		*/
		levelPieces.put(chunk, this);
	}
	
	public LevelNode(LevelNode other){
	//	potentialLeft = new ArrayList<WeightPair<String> >(other.potentialLeft);
		potentialRight = new ArrayList<WeightPair<String> >(other.potentialRight);
		children = new ArrayList<LevelNode>();
		levelChunk = other.levelChunk;
	}
	public boolean equals(LevelNode other){
		if (wildCard || other.wildCard){
			return x == other.x;
		}
		else {
			return (x==other.x) && levelChunk == other.levelChunk;
		}
	}
	public static boolean EvaluateLevel(LevelNode toBeAdded,List<LevelNode> level){
		return true;
	}
	public float GetHeuristicCost(LevelNode from){
		return 0;
	}
	public boolean AchievesGoal(){
		return false;
	}
	public List<LevelNode> ConstructLevel(){
		return null;
	}
	List<LevelNode> GetNeighbors(){
		return null;
	}
	public List<LevelNode> GetLevel(){
		PriorityQueue<LevelNode> openSet = new PriorityQueue<LevelNode>();
		
		HashSet<LevelNode> closedSet = new HashSet<LevelNode>();
		Hashtable<LevelNode,LevelNode> cameFrom = new Hashtable<LevelNode,LevelNode>();
		
		openSet.add(this);
		Hashtable<LevelNode,Float> gScore = new Hashtable<LevelNode,Float>();
		Hashtable<LevelNode,Float> fScore = new Hashtable<LevelNode,Float>();
		
		gScore.put(this,0.0f);
		fScore.put(this,0.0f);
		while (openSet.size() > 0){
			LevelNode current = openSet.poll();
			if (current.AchievesGoal()){
				return current.ConstructLevel();
			}
			closedSet.add(current);
			List<LevelNode> neighbors = current.GetNeighbors();
			for (LevelNode neighbor : neighbors){
				float tentativeGScore = gScore.get(current)+1 ; //TODO Distance
				if (!openSet.contains(neighbor) || tentativeGScore < gScore.get(neighbor)){
					cameFrom.put(neighbor, current);
					gScore.put(neighbor,tentativeGScore);
					fScore.put(neighbor, tentativeGScore+GetHeuristicCost(neighbor));
					if (!openSet.contains(neighbor)){
						openSet.add(neighbor);
					}
				}
			}
		}
		return null;
	}
}
